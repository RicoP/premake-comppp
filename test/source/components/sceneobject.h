///////////////////////////////////////////////////////////////////
// AUTOGENERATED do not edit by hand                             //
///////////////////////////////////////////////////////////////////
#pragma once
#include "serializer.h"

#include "components/objectid.h"
#include "components/collider.h"
#include "components/meshassetref.h"
#include "components/textureassetref.h"
#include "components/transform.h"
struct SceneObject {
  ObjectID ID;
  Collider collider;
  MeshAssetRef mesh;
  TextureAssetRef texture;
  Transform transform;

  void setDefaultValues() {
    std::memset(this, 0, sizeof(SceneObject));
    ID = idgen();
    collider.setDefaultValues();
    mesh.setDefaultValues();
    texture.setDefaultValues();
    transform.setDefaultValues();
  }

  bool equals(const SceneObject & rhs) const {
    return
      ID == rhs.ID &&
      collider == rhs.collider &&
      mesh == rhs.mesh &&
      texture == rhs.texture &&
      transform == rhs.transform;
  }
};

inline bool operator==(const SceneObject &lhs, const SceneObject &rhs) {
  return lhs.equals(rhs);
}

inline bool operator!=(const SceneObject &lhs, const SceneObject &rhs) {
  return !lhs.equals(rhs);
}

///////////////////////////////////////////////////////////////////
// serializer                                                    //
///////////////////////////////////////////////////////////////////
inline void serialize(SceneObject &o, ISerializer &s) {
  if(s.node_begin("SceneObject", ros::hash("SceneObject"), &o)) {
    s.key("ID");
    serialize(o.ID, s);
    s.key("collider");
    serialize(o.collider, s);
    s.key("mesh");
    serialize(o.mesh, s);
    s.key("texture");
    serialize(o.texture, s);
    s.key("transform");
    serialize(o.transform, s);
    s.node_end();
  }
  s.end();
}

///////////////////////////////////////////////////////////////////
// deserializer                                                  //
///////////////////////////////////////////////////////////////////
inline void deserialize(SceneObject &o, IDeserializer &s) {
  o.setDefaultValues();
  while (s.next_key()) {
    switch (s.hash_key()) {
      case ros::hash("ID"):
        deserialize(o.ID, s);
        break;
      case ros::hash("collider"):
        deserialize(o.collider, s);
        break;
      case ros::hash("mesh"):
        deserialize(o.mesh, s);
        break;
      case ros::hash("texture"):
        deserialize(o.texture, s);
        break;
      case ros::hash("transform"):
        deserialize(o.transform, s);
        break;
      default: s.skip_key(); break;
    }
  }
}

///////////////////////////////////////////////////////////////////
// hashing                                                       //
///////////////////////////////////////////////////////////////////
namespace ros {
  inline ros::hash_value hash(SceneObject &o) {
    ros::hash_value h = ros::hash(o.ID);
    h = ros::xor64(h);
    h ^= ros::hash(o.collider);
    h = ros::xor64(h);
    h ^= ros::hash(o.mesh);
    h = ros::xor64(h);
    h ^= ros::hash(o.texture);
    h = ros::xor64(h);
    h ^= ros::hash(o.transform);
    return h;
  }
}

///////////////////////////////////////////////////////////////////
// randomize                                                     //
///////////////////////////////////////////////////////////////////
inline void randomize(SceneObject &o, ros::hash_value & h) {
  randomize(o.ID, h);
  randomize(o.collider, h);
  randomize(o.mesh, h);
  randomize(o.texture, h);
  randomize(o.transform, h);
}
