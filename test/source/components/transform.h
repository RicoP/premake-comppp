///////////////////////////////////////////////////////////////////
// AUTOGENERATED do not edit by hand                             //
///////////////////////////////////////////////////////////////////
#pragma once
#include "serializer.h"

#include "components/matrix4.h"
#include "components/vector3.h"
#include "components/quaternion.h"
#include "components/vector3.h"
struct Transform {
  matrix4 mvt;
  vector3 position;
  quaternion rotation;
  vector3 scale;

  void setDefaultValues() {
    std::memset(this, 0, sizeof(Transform));
    mvt = identity4();
    position = vector(0,0,0);
    rotation = qidentity();
    scale = vector(1,1,1);
  }

  bool equals(const Transform & rhs) const {
    return
      mvt == rhs.mvt &&
      position == rhs.position &&
      rotation == rhs.rotation &&
      scale == rhs.scale;
  }
};

inline bool operator==(const Transform &lhs, const Transform &rhs) {
  return lhs.equals(rhs);
}

inline bool operator!=(const Transform &lhs, const Transform &rhs) {
  return !lhs.equals(rhs);
}

///////////////////////////////////////////////////////////////////
// serializer                                                    //
///////////////////////////////////////////////////////////////////
inline void serialize(Transform &o, ISerializer &s) {
  if(s.node_begin("Transform", ros::hash("Transform"), &o)) {
    s.key("mvt");
    serialize(o.mvt, s);
    s.key("position");
    serialize(o.position, s);
    s.key("rotation");
    serialize(o.rotation, s);
    s.key("scale");
    serialize(o.scale, s);
    s.node_end();
  }
  s.end();
}

///////////////////////////////////////////////////////////////////
// deserializer                                                  //
///////////////////////////////////////////////////////////////////
inline void deserialize(Transform &o, IDeserializer &s) {
  o.setDefaultValues();
  while (s.next_key()) {
    switch (s.hash_key()) {
      case ros::hash("mvt"):
        deserialize(o.mvt, s);
        break;
      case ros::hash("position"):
        deserialize(o.position, s);
        break;
      case ros::hash("rotation"):
        deserialize(o.rotation, s);
        break;
      case ros::hash("scale"):
        deserialize(o.scale, s);
        break;
      default: s.skip_key(); break;
    }
  }
}

///////////////////////////////////////////////////////////////////
// hashing                                                       //
///////////////////////////////////////////////////////////////////
namespace ros {
  inline ros::hash_value hash(Transform &o) {
    ros::hash_value h = ros::hash(o.mvt);
    h = ros::xor64(h);
    h ^= ros::hash(o.position);
    h = ros::xor64(h);
    h ^= ros::hash(o.rotation);
    h = ros::xor64(h);
    h ^= ros::hash(o.scale);
    return h;
  }
}

///////////////////////////////////////////////////////////////////
// randomize                                                     //
///////////////////////////////////////////////////////////////////
inline void randomize(Transform &o, ros::hash_value & h) {
  randomize(o.mvt, h);
  randomize(o.position, h);
  randomize(o.rotation, h);
  randomize(o.scale, h);
}
