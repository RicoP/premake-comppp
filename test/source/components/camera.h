///////////////////////////////////////////////////////////////////
// AUTOGENERATED do not edit by hand                             //
///////////////////////////////////////////////////////////////////
#pragma once
#include "serializer.h"

struct Camera {
  float far_plane;
  float fov;
  matrix4 lookat;
  float near_plane;
  matrix4 projection;

  void setDefaultValues() {
    std::memset(this, 0, sizeof(Camera));
    far_plane = 1000;
    fov = 70;
    lookat = identity4();
    near_plane = 0.1f;
    projection = identity4();
  }

  bool equals(const Camera & rhs) const {
    return
      far_plane == rhs.far_plane &&
      fov == rhs.fov &&
      lookat == rhs.lookat &&
      near_plane == rhs.near_plane &&
      projection == rhs.projection;
  }
};

inline bool operator==(const Camera &lhs, const Camera &rhs) {
  return lhs.equals(rhs);
}

inline bool operator!=(const Camera &lhs, const Camera &rhs) {
  return !lhs.equals(rhs);
}

///////////////////////////////////////////////////////////////////
// serializer                                                    //
///////////////////////////////////////////////////////////////////
inline void serialize(Camera &o, ISerializer &s) {
  s.begin();
  s.key("far_plane");
  serialize(o.far_plane, s);
  s.key("fov");
  serialize(o.fov, s);
  s.key("lookat");
  serialize(o.lookat, s);
  s.key("near_plane");
  serialize(o.near_plane, s);
  s.key("projection");
  serialize(o.projection, s);
  s.end();
}

///////////////////////////////////////////////////////////////////
// deserializer                                                  //
///////////////////////////////////////////////////////////////////
inline void deserialize(Camera &o, IDeserializer &s) {
  o.setDefaultValues();
  while (s.next_key()) {
    switch (s.hash_key()) {
      case ros::hash("far_plane"):
        deserialize(o.far_plane, s);
        break;
      case ros::hash("fov"):
        deserialize(o.fov, s);
        break;
      case ros::hash("lookat"):
        deserialize(o.lookat, s);
        break;
      case ros::hash("near_plane"):
        deserialize(o.near_plane, s);
        break;
      case ros::hash("projection"):
        deserialize(o.projection, s);
        break;
      default: s.skip_key(); break;
    }
  }
}

///////////////////////////////////////////////////////////////////
// hashing                                                       //
///////////////////////////////////////////////////////////////////
namespace ros {
  inline ros::hash_value hash(Camera &o) {
    ros::hash_value h = ros::hash(o.far_plane);
    h = ros::xor64(h);
    h ^= ros::hash(o.fov);
    h = ros::xor64(h);
    h ^= ros::hash(o.lookat);
    h = ros::xor64(h);
    h ^= ros::hash(o.near_plane);
    h = ros::xor64(h);
    h ^= ros::hash(o.projection);
    return h;
  }
}
